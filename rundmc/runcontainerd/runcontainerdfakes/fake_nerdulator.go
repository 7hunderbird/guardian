// Code generated by counterfeiter. DO NOT EDIT.
package runcontainerdfakes

import (
	"sync"

	"code.cloudfoundry.org/guardian/rundmc/runcontainerd"
	"github.com/containerd/containerd"
	"github.com/containerd/containerd/cio"
	specs "github.com/opencontainers/runtime-spec/specs-go"
)

type FakeNerdulator struct {
	CreateContainerStub        func(id string, spec specs.Spec) (containerd.Container, error)
	createContainerMutex       sync.RWMutex
	createContainerArgsForCall []struct {
		id   string
		spec specs.Spec
	}
	createContainerReturns struct {
		result1 containerd.Container
		result2 error
	}
	createContainerReturnsOnCall map[int]struct {
		result1 containerd.Container
		result2 error
	}
	CreateTaskStub        func(io cio.Creator, container containerd.Container) (containerd.Task, error)
	createTaskMutex       sync.RWMutex
	createTaskArgsForCall []struct {
		io        cio.Creator
		container containerd.Container
	}
	createTaskReturns struct {
		result1 containerd.Task
		result2 error
	}
	createTaskReturnsOnCall map[int]struct {
		result1 containerd.Task
		result2 error
	}
	StartTaskStub        func(task containerd.Task) error
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		task containerd.Task
	}
	startTaskReturns struct {
		result1 error
	}
	startTaskReturnsOnCall map[int]struct {
		result1 error
	}
	LoadContainerStub        func(id string) (containerd.Container, error)
	loadContainerMutex       sync.RWMutex
	loadContainerArgsForCall []struct {
		id string
	}
	loadContainerReturns struct {
		result1 containerd.Container
		result2 error
	}
	loadContainerReturnsOnCall map[int]struct {
		result1 containerd.Container
		result2 error
	}
	GetTaskStub        func(container containerd.Container) (containerd.Task, error)
	getTaskMutex       sync.RWMutex
	getTaskArgsForCall []struct {
		container containerd.Container
	}
	getTaskReturns struct {
		result1 containerd.Task
		result2 error
	}
	getTaskReturnsOnCall map[int]struct {
		result1 containerd.Task
		result2 error
	}
	GetTaskPidStub        func(task containerd.Task) int
	getTaskPidMutex       sync.RWMutex
	getTaskPidArgsForCall []struct {
		task containerd.Task
	}
	getTaskPidReturns struct {
		result1 int
	}
	getTaskPidReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNerdulator) CreateContainer(id string, spec specs.Spec) (containerd.Container, error) {
	fake.createContainerMutex.Lock()
	ret, specificReturn := fake.createContainerReturnsOnCall[len(fake.createContainerArgsForCall)]
	fake.createContainerArgsForCall = append(fake.createContainerArgsForCall, struct {
		id   string
		spec specs.Spec
	}{id, spec})
	fake.recordInvocation("CreateContainer", []interface{}{id, spec})
	fake.createContainerMutex.Unlock()
	if fake.CreateContainerStub != nil {
		return fake.CreateContainerStub(id, spec)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createContainerReturns.result1, fake.createContainerReturns.result2
}

func (fake *FakeNerdulator) CreateContainerCallCount() int {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return len(fake.createContainerArgsForCall)
}

func (fake *FakeNerdulator) CreateContainerArgsForCall(i int) (string, specs.Spec) {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return fake.createContainerArgsForCall[i].id, fake.createContainerArgsForCall[i].spec
}

func (fake *FakeNerdulator) CreateContainerReturns(result1 containerd.Container, result2 error) {
	fake.CreateContainerStub = nil
	fake.createContainerReturns = struct {
		result1 containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeNerdulator) CreateContainerReturnsOnCall(i int, result1 containerd.Container, result2 error) {
	fake.CreateContainerStub = nil
	if fake.createContainerReturnsOnCall == nil {
		fake.createContainerReturnsOnCall = make(map[int]struct {
			result1 containerd.Container
			result2 error
		})
	}
	fake.createContainerReturnsOnCall[i] = struct {
		result1 containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeNerdulator) CreateTask(io cio.Creator, container containerd.Container) (containerd.Task, error) {
	fake.createTaskMutex.Lock()
	ret, specificReturn := fake.createTaskReturnsOnCall[len(fake.createTaskArgsForCall)]
	fake.createTaskArgsForCall = append(fake.createTaskArgsForCall, struct {
		io        cio.Creator
		container containerd.Container
	}{io, container})
	fake.recordInvocation("CreateTask", []interface{}{io, container})
	fake.createTaskMutex.Unlock()
	if fake.CreateTaskStub != nil {
		return fake.CreateTaskStub(io, container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createTaskReturns.result1, fake.createTaskReturns.result2
}

func (fake *FakeNerdulator) CreateTaskCallCount() int {
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	return len(fake.createTaskArgsForCall)
}

func (fake *FakeNerdulator) CreateTaskArgsForCall(i int) (cio.Creator, containerd.Container) {
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	return fake.createTaskArgsForCall[i].io, fake.createTaskArgsForCall[i].container
}

func (fake *FakeNerdulator) CreateTaskReturns(result1 containerd.Task, result2 error) {
	fake.CreateTaskStub = nil
	fake.createTaskReturns = struct {
		result1 containerd.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeNerdulator) CreateTaskReturnsOnCall(i int, result1 containerd.Task, result2 error) {
	fake.CreateTaskStub = nil
	if fake.createTaskReturnsOnCall == nil {
		fake.createTaskReturnsOnCall = make(map[int]struct {
			result1 containerd.Task
			result2 error
		})
	}
	fake.createTaskReturnsOnCall[i] = struct {
		result1 containerd.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeNerdulator) StartTask(task containerd.Task) error {
	fake.startTaskMutex.Lock()
	ret, specificReturn := fake.startTaskReturnsOnCall[len(fake.startTaskArgsForCall)]
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		task containerd.Task
	}{task})
	fake.recordInvocation("StartTask", []interface{}{task})
	fake.startTaskMutex.Unlock()
	if fake.StartTaskStub != nil {
		return fake.StartTaskStub(task)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startTaskReturns.result1
}

func (fake *FakeNerdulator) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeNerdulator) StartTaskArgsForCall(i int) containerd.Task {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return fake.startTaskArgsForCall[i].task
}

func (fake *FakeNerdulator) StartTaskReturns(result1 error) {
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNerdulator) StartTaskReturnsOnCall(i int, result1 error) {
	fake.StartTaskStub = nil
	if fake.startTaskReturnsOnCall == nil {
		fake.startTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNerdulator) LoadContainer(id string) (containerd.Container, error) {
	fake.loadContainerMutex.Lock()
	ret, specificReturn := fake.loadContainerReturnsOnCall[len(fake.loadContainerArgsForCall)]
	fake.loadContainerArgsForCall = append(fake.loadContainerArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("LoadContainer", []interface{}{id})
	fake.loadContainerMutex.Unlock()
	if fake.LoadContainerStub != nil {
		return fake.LoadContainerStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadContainerReturns.result1, fake.loadContainerReturns.result2
}

func (fake *FakeNerdulator) LoadContainerCallCount() int {
	fake.loadContainerMutex.RLock()
	defer fake.loadContainerMutex.RUnlock()
	return len(fake.loadContainerArgsForCall)
}

func (fake *FakeNerdulator) LoadContainerArgsForCall(i int) string {
	fake.loadContainerMutex.RLock()
	defer fake.loadContainerMutex.RUnlock()
	return fake.loadContainerArgsForCall[i].id
}

func (fake *FakeNerdulator) LoadContainerReturns(result1 containerd.Container, result2 error) {
	fake.LoadContainerStub = nil
	fake.loadContainerReturns = struct {
		result1 containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeNerdulator) LoadContainerReturnsOnCall(i int, result1 containerd.Container, result2 error) {
	fake.LoadContainerStub = nil
	if fake.loadContainerReturnsOnCall == nil {
		fake.loadContainerReturnsOnCall = make(map[int]struct {
			result1 containerd.Container
			result2 error
		})
	}
	fake.loadContainerReturnsOnCall[i] = struct {
		result1 containerd.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeNerdulator) GetTask(container containerd.Container) (containerd.Task, error) {
	fake.getTaskMutex.Lock()
	ret, specificReturn := fake.getTaskReturnsOnCall[len(fake.getTaskArgsForCall)]
	fake.getTaskArgsForCall = append(fake.getTaskArgsForCall, struct {
		container containerd.Container
	}{container})
	fake.recordInvocation("GetTask", []interface{}{container})
	fake.getTaskMutex.Unlock()
	if fake.GetTaskStub != nil {
		return fake.GetTaskStub(container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getTaskReturns.result1, fake.getTaskReturns.result2
}

func (fake *FakeNerdulator) GetTaskCallCount() int {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return len(fake.getTaskArgsForCall)
}

func (fake *FakeNerdulator) GetTaskArgsForCall(i int) containerd.Container {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return fake.getTaskArgsForCall[i].container
}

func (fake *FakeNerdulator) GetTaskReturns(result1 containerd.Task, result2 error) {
	fake.GetTaskStub = nil
	fake.getTaskReturns = struct {
		result1 containerd.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeNerdulator) GetTaskReturnsOnCall(i int, result1 containerd.Task, result2 error) {
	fake.GetTaskStub = nil
	if fake.getTaskReturnsOnCall == nil {
		fake.getTaskReturnsOnCall = make(map[int]struct {
			result1 containerd.Task
			result2 error
		})
	}
	fake.getTaskReturnsOnCall[i] = struct {
		result1 containerd.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeNerdulator) GetTaskPid(task containerd.Task) int {
	fake.getTaskPidMutex.Lock()
	ret, specificReturn := fake.getTaskPidReturnsOnCall[len(fake.getTaskPidArgsForCall)]
	fake.getTaskPidArgsForCall = append(fake.getTaskPidArgsForCall, struct {
		task containerd.Task
	}{task})
	fake.recordInvocation("GetTaskPid", []interface{}{task})
	fake.getTaskPidMutex.Unlock()
	if fake.GetTaskPidStub != nil {
		return fake.GetTaskPidStub(task)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getTaskPidReturns.result1
}

func (fake *FakeNerdulator) GetTaskPidCallCount() int {
	fake.getTaskPidMutex.RLock()
	defer fake.getTaskPidMutex.RUnlock()
	return len(fake.getTaskPidArgsForCall)
}

func (fake *FakeNerdulator) GetTaskPidArgsForCall(i int) containerd.Task {
	fake.getTaskPidMutex.RLock()
	defer fake.getTaskPidMutex.RUnlock()
	return fake.getTaskPidArgsForCall[i].task
}

func (fake *FakeNerdulator) GetTaskPidReturns(result1 int) {
	fake.GetTaskPidStub = nil
	fake.getTaskPidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeNerdulator) GetTaskPidReturnsOnCall(i int, result1 int) {
	fake.GetTaskPidStub = nil
	if fake.getTaskPidReturnsOnCall == nil {
		fake.getTaskPidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getTaskPidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeNerdulator) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	fake.loadContainerMutex.RLock()
	defer fake.loadContainerMutex.RUnlock()
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	fake.getTaskPidMutex.RLock()
	defer fake.getTaskPidMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNerdulator) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ runcontainerd.Nerdulator = new(FakeNerdulator)

// Code generated by counterfeiter. DO NOT EDIT.
package runcontainerdfakes

import (
	"context"
	"sync"
	"syscall"

	"code.cloudfoundry.org/guardian/rundmc/runcontainerd"
	"github.com/containerd/containerd"
	"github.com/containerd/containerd/api/types"
	"github.com/containerd/containerd/cio"
	specs "github.com/opencontainers/runtime-spec/specs-go"
)

type FakeTask struct {
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	PidStub        func() uint32
	pidMutex       sync.RWMutex
	pidArgsForCall []struct{}
	pidReturns     struct {
		result1 uint32
	}
	pidReturnsOnCall map[int]struct {
		result1 uint32
	}
	StartStub        func(context.Context) error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 context.Context
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(context.Context, ...containerd.ProcessDeleteOpts) (*containerd.ExitStatus, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 []containerd.ProcessDeleteOpts
	}
	deleteReturns struct {
		result1 *containerd.ExitStatus
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 *containerd.ExitStatus
		result2 error
	}
	KillStub        func(context.Context, syscall.Signal, ...containerd.KillOpts) error
	killMutex       sync.RWMutex
	killArgsForCall []struct {
		arg1 context.Context
		arg2 syscall.Signal
		arg3 []containerd.KillOpts
	}
	killReturns struct {
		result1 error
	}
	killReturnsOnCall map[int]struct {
		result1 error
	}
	WaitStub        func(context.Context) (<-chan containerd.ExitStatus, error)
	waitMutex       sync.RWMutex
	waitArgsForCall []struct {
		arg1 context.Context
	}
	waitReturns struct {
		result1 <-chan containerd.ExitStatus
		result2 error
	}
	waitReturnsOnCall map[int]struct {
		result1 <-chan containerd.ExitStatus
		result2 error
	}
	CloseIOStub        func(context.Context, ...containerd.IOCloserOpts) error
	closeIOMutex       sync.RWMutex
	closeIOArgsForCall []struct {
		arg1 context.Context
		arg2 []containerd.IOCloserOpts
	}
	closeIOReturns struct {
		result1 error
	}
	closeIOReturnsOnCall map[int]struct {
		result1 error
	}
	ResizeStub        func(ctx context.Context, w, h uint32) error
	resizeMutex       sync.RWMutex
	resizeArgsForCall []struct {
		ctx context.Context
		w   uint32
		h   uint32
	}
	resizeReturns struct {
		result1 error
	}
	resizeReturnsOnCall map[int]struct {
		result1 error
	}
	IOStub        func() cio.IO
	iOMutex       sync.RWMutex
	iOArgsForCall []struct{}
	iOReturns     struct {
		result1 cio.IO
	}
	iOReturnsOnCall map[int]struct {
		result1 cio.IO
	}
	StatusStub        func(context.Context) (containerd.Status, error)
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
		arg1 context.Context
	}
	statusReturns struct {
		result1 containerd.Status
		result2 error
	}
	statusReturnsOnCall map[int]struct {
		result1 containerd.Status
		result2 error
	}
	PauseStub        func(context.Context) error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct {
		arg1 context.Context
	}
	pauseReturns struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	ResumeStub        func(context.Context) error
	resumeMutex       sync.RWMutex
	resumeArgsForCall []struct {
		arg1 context.Context
	}
	resumeReturns struct {
		result1 error
	}
	resumeReturnsOnCall map[int]struct {
		result1 error
	}
	ExecStub        func(context.Context, string, *specs.Process, cio.Creator) (containerd.Process, error)
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *specs.Process
		arg4 cio.Creator
	}
	execReturns struct {
		result1 containerd.Process
		result2 error
	}
	execReturnsOnCall map[int]struct {
		result1 containerd.Process
		result2 error
	}
	PidsStub        func(context.Context) ([]containerd.ProcessInfo, error)
	pidsMutex       sync.RWMutex
	pidsArgsForCall []struct {
		arg1 context.Context
	}
	pidsReturns struct {
		result1 []containerd.ProcessInfo
		result2 error
	}
	pidsReturnsOnCall map[int]struct {
		result1 []containerd.ProcessInfo
		result2 error
	}
	CheckpointStub        func(context.Context, ...containerd.CheckpointTaskOpts) (containerd.Image, error)
	checkpointMutex       sync.RWMutex
	checkpointArgsForCall []struct {
		arg1 context.Context
		arg2 []containerd.CheckpointTaskOpts
	}
	checkpointReturns struct {
		result1 containerd.Image
		result2 error
	}
	checkpointReturnsOnCall map[int]struct {
		result1 containerd.Image
		result2 error
	}
	UpdateStub        func(context.Context, ...containerd.UpdateTaskOpts) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 []containerd.UpdateTaskOpts
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	LoadProcessStub        func(context.Context, string, cio.Attach) (containerd.Process, error)
	loadProcessMutex       sync.RWMutex
	loadProcessArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 cio.Attach
	}
	loadProcessReturns struct {
		result1 containerd.Process
		result2 error
	}
	loadProcessReturnsOnCall map[int]struct {
		result1 containerd.Process
		result2 error
	}
	MetricsStub        func(context.Context) (*types.Metric, error)
	metricsMutex       sync.RWMutex
	metricsArgsForCall []struct {
		arg1 context.Context
	}
	metricsReturns struct {
		result1 *types.Metric
		result2 error
	}
	metricsReturnsOnCall map[int]struct {
		result1 *types.Metric
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTask) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeTask) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeTask) IDReturns(result1 string) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) IDReturnsOnCall(i int, result1 string) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) Pid() uint32 {
	fake.pidMutex.Lock()
	ret, specificReturn := fake.pidReturnsOnCall[len(fake.pidArgsForCall)]
	fake.pidArgsForCall = append(fake.pidArgsForCall, struct{}{})
	fake.recordInvocation("Pid", []interface{}{})
	fake.pidMutex.Unlock()
	if fake.PidStub != nil {
		return fake.PidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pidReturns.result1
}

func (fake *FakeTask) PidCallCount() int {
	fake.pidMutex.RLock()
	defer fake.pidMutex.RUnlock()
	return len(fake.pidArgsForCall)
}

func (fake *FakeTask) PidReturns(result1 uint32) {
	fake.PidStub = nil
	fake.pidReturns = struct {
		result1 uint32
	}{result1}
}

func (fake *FakeTask) PidReturnsOnCall(i int, result1 uint32) {
	fake.PidStub = nil
	if fake.pidReturnsOnCall == nil {
		fake.pidReturnsOnCall = make(map[int]struct {
			result1 uint32
		})
	}
	fake.pidReturnsOnCall[i] = struct {
		result1 uint32
	}{result1}
}

func (fake *FakeTask) Start(arg1 context.Context) error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Start", []interface{}{arg1})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startReturns.result1
}

func (fake *FakeTask) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeTask) StartArgsForCall(i int) context.Context {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return fake.startArgsForCall[i].arg1
}

func (fake *FakeTask) StartReturns(result1 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) StartReturnsOnCall(i int, result1 error) {
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) Delete(arg1 context.Context, arg2 ...containerd.ProcessDeleteOpts) (*containerd.ExitStatus, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 []containerd.ProcessDeleteOpts
	}{arg1, arg2})
	fake.recordInvocation("Delete", []interface{}{arg1, arg2})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteReturns.result1, fake.deleteReturns.result2
}

func (fake *FakeTask) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeTask) DeleteArgsForCall(i int) (context.Context, []containerd.ProcessDeleteOpts) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].arg1, fake.deleteArgsForCall[i].arg2
}

func (fake *FakeTask) DeleteReturns(result1 *containerd.ExitStatus, result2 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 *containerd.ExitStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) DeleteReturnsOnCall(i int, result1 *containerd.ExitStatus, result2 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 *containerd.ExitStatus
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 *containerd.ExitStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) Kill(arg1 context.Context, arg2 syscall.Signal, arg3 ...containerd.KillOpts) error {
	fake.killMutex.Lock()
	ret, specificReturn := fake.killReturnsOnCall[len(fake.killArgsForCall)]
	fake.killArgsForCall = append(fake.killArgsForCall, struct {
		arg1 context.Context
		arg2 syscall.Signal
		arg3 []containerd.KillOpts
	}{arg1, arg2, arg3})
	fake.recordInvocation("Kill", []interface{}{arg1, arg2, arg3})
	fake.killMutex.Unlock()
	if fake.KillStub != nil {
		return fake.KillStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.killReturns.result1
}

func (fake *FakeTask) KillCallCount() int {
	fake.killMutex.RLock()
	defer fake.killMutex.RUnlock()
	return len(fake.killArgsForCall)
}

func (fake *FakeTask) KillArgsForCall(i int) (context.Context, syscall.Signal, []containerd.KillOpts) {
	fake.killMutex.RLock()
	defer fake.killMutex.RUnlock()
	return fake.killArgsForCall[i].arg1, fake.killArgsForCall[i].arg2, fake.killArgsForCall[i].arg3
}

func (fake *FakeTask) KillReturns(result1 error) {
	fake.KillStub = nil
	fake.killReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) KillReturnsOnCall(i int, result1 error) {
	fake.KillStub = nil
	if fake.killReturnsOnCall == nil {
		fake.killReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.killReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) Wait(arg1 context.Context) (<-chan containerd.ExitStatus, error) {
	fake.waitMutex.Lock()
	ret, specificReturn := fake.waitReturnsOnCall[len(fake.waitArgsForCall)]
	fake.waitArgsForCall = append(fake.waitArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Wait", []interface{}{arg1})
	fake.waitMutex.Unlock()
	if fake.WaitStub != nil {
		return fake.WaitStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.waitReturns.result1, fake.waitReturns.result2
}

func (fake *FakeTask) WaitCallCount() int {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return len(fake.waitArgsForCall)
}

func (fake *FakeTask) WaitArgsForCall(i int) context.Context {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return fake.waitArgsForCall[i].arg1
}

func (fake *FakeTask) WaitReturns(result1 <-chan containerd.ExitStatus, result2 error) {
	fake.WaitStub = nil
	fake.waitReturns = struct {
		result1 <-chan containerd.ExitStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) WaitReturnsOnCall(i int, result1 <-chan containerd.ExitStatus, result2 error) {
	fake.WaitStub = nil
	if fake.waitReturnsOnCall == nil {
		fake.waitReturnsOnCall = make(map[int]struct {
			result1 <-chan containerd.ExitStatus
			result2 error
		})
	}
	fake.waitReturnsOnCall[i] = struct {
		result1 <-chan containerd.ExitStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) CloseIO(arg1 context.Context, arg2 ...containerd.IOCloserOpts) error {
	fake.closeIOMutex.Lock()
	ret, specificReturn := fake.closeIOReturnsOnCall[len(fake.closeIOArgsForCall)]
	fake.closeIOArgsForCall = append(fake.closeIOArgsForCall, struct {
		arg1 context.Context
		arg2 []containerd.IOCloserOpts
	}{arg1, arg2})
	fake.recordInvocation("CloseIO", []interface{}{arg1, arg2})
	fake.closeIOMutex.Unlock()
	if fake.CloseIOStub != nil {
		return fake.CloseIOStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.closeIOReturns.result1
}

func (fake *FakeTask) CloseIOCallCount() int {
	fake.closeIOMutex.RLock()
	defer fake.closeIOMutex.RUnlock()
	return len(fake.closeIOArgsForCall)
}

func (fake *FakeTask) CloseIOArgsForCall(i int) (context.Context, []containerd.IOCloserOpts) {
	fake.closeIOMutex.RLock()
	defer fake.closeIOMutex.RUnlock()
	return fake.closeIOArgsForCall[i].arg1, fake.closeIOArgsForCall[i].arg2
}

func (fake *FakeTask) CloseIOReturns(result1 error) {
	fake.CloseIOStub = nil
	fake.closeIOReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) CloseIOReturnsOnCall(i int, result1 error) {
	fake.CloseIOStub = nil
	if fake.closeIOReturnsOnCall == nil {
		fake.closeIOReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeIOReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) Resize(ctx context.Context, w uint32, h uint32) error {
	fake.resizeMutex.Lock()
	ret, specificReturn := fake.resizeReturnsOnCall[len(fake.resizeArgsForCall)]
	fake.resizeArgsForCall = append(fake.resizeArgsForCall, struct {
		ctx context.Context
		w   uint32
		h   uint32
	}{ctx, w, h})
	fake.recordInvocation("Resize", []interface{}{ctx, w, h})
	fake.resizeMutex.Unlock()
	if fake.ResizeStub != nil {
		return fake.ResizeStub(ctx, w, h)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resizeReturns.result1
}

func (fake *FakeTask) ResizeCallCount() int {
	fake.resizeMutex.RLock()
	defer fake.resizeMutex.RUnlock()
	return len(fake.resizeArgsForCall)
}

func (fake *FakeTask) ResizeArgsForCall(i int) (context.Context, uint32, uint32) {
	fake.resizeMutex.RLock()
	defer fake.resizeMutex.RUnlock()
	return fake.resizeArgsForCall[i].ctx, fake.resizeArgsForCall[i].w, fake.resizeArgsForCall[i].h
}

func (fake *FakeTask) ResizeReturns(result1 error) {
	fake.ResizeStub = nil
	fake.resizeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) ResizeReturnsOnCall(i int, result1 error) {
	fake.ResizeStub = nil
	if fake.resizeReturnsOnCall == nil {
		fake.resizeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resizeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) IO() cio.IO {
	fake.iOMutex.Lock()
	ret, specificReturn := fake.iOReturnsOnCall[len(fake.iOArgsForCall)]
	fake.iOArgsForCall = append(fake.iOArgsForCall, struct{}{})
	fake.recordInvocation("IO", []interface{}{})
	fake.iOMutex.Unlock()
	if fake.IOStub != nil {
		return fake.IOStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iOReturns.result1
}

func (fake *FakeTask) IOCallCount() int {
	fake.iOMutex.RLock()
	defer fake.iOMutex.RUnlock()
	return len(fake.iOArgsForCall)
}

func (fake *FakeTask) IOReturns(result1 cio.IO) {
	fake.IOStub = nil
	fake.iOReturns = struct {
		result1 cio.IO
	}{result1}
}

func (fake *FakeTask) IOReturnsOnCall(i int, result1 cio.IO) {
	fake.IOStub = nil
	if fake.iOReturnsOnCall == nil {
		fake.iOReturnsOnCall = make(map[int]struct {
			result1 cio.IO
		})
	}
	fake.iOReturnsOnCall[i] = struct {
		result1 cio.IO
	}{result1}
}

func (fake *FakeTask) Status(arg1 context.Context) (containerd.Status, error) {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Status", []interface{}{arg1})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.statusReturns.result1, fake.statusReturns.result2
}

func (fake *FakeTask) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeTask) StatusArgsForCall(i int) context.Context {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return fake.statusArgsForCall[i].arg1
}

func (fake *FakeTask) StatusReturns(result1 containerd.Status, result2 error) {
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 containerd.Status
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) StatusReturnsOnCall(i int, result1 containerd.Status, result2 error) {
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 containerd.Status
			result2 error
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 containerd.Status
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) Pause(arg1 context.Context) error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Pause", []interface{}{arg1})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pauseReturns.result1
}

func (fake *FakeTask) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakeTask) PauseArgsForCall(i int) context.Context {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return fake.pauseArgsForCall[i].arg1
}

func (fake *FakeTask) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) PauseReturnsOnCall(i int, result1 error) {
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) Resume(arg1 context.Context) error {
	fake.resumeMutex.Lock()
	ret, specificReturn := fake.resumeReturnsOnCall[len(fake.resumeArgsForCall)]
	fake.resumeArgsForCall = append(fake.resumeArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Resume", []interface{}{arg1})
	fake.resumeMutex.Unlock()
	if fake.ResumeStub != nil {
		return fake.ResumeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resumeReturns.result1
}

func (fake *FakeTask) ResumeCallCount() int {
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	return len(fake.resumeArgsForCall)
}

func (fake *FakeTask) ResumeArgsForCall(i int) context.Context {
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	return fake.resumeArgsForCall[i].arg1
}

func (fake *FakeTask) ResumeReturns(result1 error) {
	fake.ResumeStub = nil
	fake.resumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) ResumeReturnsOnCall(i int, result1 error) {
	fake.ResumeStub = nil
	if fake.resumeReturnsOnCall == nil {
		fake.resumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) Exec(arg1 context.Context, arg2 string, arg3 *specs.Process, arg4 cio.Creator) (containerd.Process, error) {
	fake.execMutex.Lock()
	ret, specificReturn := fake.execReturnsOnCall[len(fake.execArgsForCall)]
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *specs.Process
		arg4 cio.Creator
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Exec", []interface{}{arg1, arg2, arg3, arg4})
	fake.execMutex.Unlock()
	if fake.ExecStub != nil {
		return fake.ExecStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.execReturns.result1, fake.execReturns.result2
}

func (fake *FakeTask) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *FakeTask) ExecArgsForCall(i int) (context.Context, string, *specs.Process, cio.Creator) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return fake.execArgsForCall[i].arg1, fake.execArgsForCall[i].arg2, fake.execArgsForCall[i].arg3, fake.execArgsForCall[i].arg4
}

func (fake *FakeTask) ExecReturns(result1 containerd.Process, result2 error) {
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 containerd.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) ExecReturnsOnCall(i int, result1 containerd.Process, result2 error) {
	fake.ExecStub = nil
	if fake.execReturnsOnCall == nil {
		fake.execReturnsOnCall = make(map[int]struct {
			result1 containerd.Process
			result2 error
		})
	}
	fake.execReturnsOnCall[i] = struct {
		result1 containerd.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) Pids(arg1 context.Context) ([]containerd.ProcessInfo, error) {
	fake.pidsMutex.Lock()
	ret, specificReturn := fake.pidsReturnsOnCall[len(fake.pidsArgsForCall)]
	fake.pidsArgsForCall = append(fake.pidsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Pids", []interface{}{arg1})
	fake.pidsMutex.Unlock()
	if fake.PidsStub != nil {
		return fake.PidsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pidsReturns.result1, fake.pidsReturns.result2
}

func (fake *FakeTask) PidsCallCount() int {
	fake.pidsMutex.RLock()
	defer fake.pidsMutex.RUnlock()
	return len(fake.pidsArgsForCall)
}

func (fake *FakeTask) PidsArgsForCall(i int) context.Context {
	fake.pidsMutex.RLock()
	defer fake.pidsMutex.RUnlock()
	return fake.pidsArgsForCall[i].arg1
}

func (fake *FakeTask) PidsReturns(result1 []containerd.ProcessInfo, result2 error) {
	fake.PidsStub = nil
	fake.pidsReturns = struct {
		result1 []containerd.ProcessInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) PidsReturnsOnCall(i int, result1 []containerd.ProcessInfo, result2 error) {
	fake.PidsStub = nil
	if fake.pidsReturnsOnCall == nil {
		fake.pidsReturnsOnCall = make(map[int]struct {
			result1 []containerd.ProcessInfo
			result2 error
		})
	}
	fake.pidsReturnsOnCall[i] = struct {
		result1 []containerd.ProcessInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) Checkpoint(arg1 context.Context, arg2 ...containerd.CheckpointTaskOpts) (containerd.Image, error) {
	fake.checkpointMutex.Lock()
	ret, specificReturn := fake.checkpointReturnsOnCall[len(fake.checkpointArgsForCall)]
	fake.checkpointArgsForCall = append(fake.checkpointArgsForCall, struct {
		arg1 context.Context
		arg2 []containerd.CheckpointTaskOpts
	}{arg1, arg2})
	fake.recordInvocation("Checkpoint", []interface{}{arg1, arg2})
	fake.checkpointMutex.Unlock()
	if fake.CheckpointStub != nil {
		return fake.CheckpointStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checkpointReturns.result1, fake.checkpointReturns.result2
}

func (fake *FakeTask) CheckpointCallCount() int {
	fake.checkpointMutex.RLock()
	defer fake.checkpointMutex.RUnlock()
	return len(fake.checkpointArgsForCall)
}

func (fake *FakeTask) CheckpointArgsForCall(i int) (context.Context, []containerd.CheckpointTaskOpts) {
	fake.checkpointMutex.RLock()
	defer fake.checkpointMutex.RUnlock()
	return fake.checkpointArgsForCall[i].arg1, fake.checkpointArgsForCall[i].arg2
}

func (fake *FakeTask) CheckpointReturns(result1 containerd.Image, result2 error) {
	fake.CheckpointStub = nil
	fake.checkpointReturns = struct {
		result1 containerd.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) CheckpointReturnsOnCall(i int, result1 containerd.Image, result2 error) {
	fake.CheckpointStub = nil
	if fake.checkpointReturnsOnCall == nil {
		fake.checkpointReturnsOnCall = make(map[int]struct {
			result1 containerd.Image
			result2 error
		})
	}
	fake.checkpointReturnsOnCall[i] = struct {
		result1 containerd.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) Update(arg1 context.Context, arg2 ...containerd.UpdateTaskOpts) error {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 []containerd.UpdateTaskOpts
	}{arg1, arg2})
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateReturns.result1
}

func (fake *FakeTask) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeTask) UpdateArgsForCall(i int) (context.Context, []containerd.UpdateTaskOpts) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].arg1, fake.updateArgsForCall[i].arg2
}

func (fake *FakeTask) UpdateReturns(result1 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) UpdateReturnsOnCall(i int, result1 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) LoadProcess(arg1 context.Context, arg2 string, arg3 cio.Attach) (containerd.Process, error) {
	fake.loadProcessMutex.Lock()
	ret, specificReturn := fake.loadProcessReturnsOnCall[len(fake.loadProcessArgsForCall)]
	fake.loadProcessArgsForCall = append(fake.loadProcessArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 cio.Attach
	}{arg1, arg2, arg3})
	fake.recordInvocation("LoadProcess", []interface{}{arg1, arg2, arg3})
	fake.loadProcessMutex.Unlock()
	if fake.LoadProcessStub != nil {
		return fake.LoadProcessStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadProcessReturns.result1, fake.loadProcessReturns.result2
}

func (fake *FakeTask) LoadProcessCallCount() int {
	fake.loadProcessMutex.RLock()
	defer fake.loadProcessMutex.RUnlock()
	return len(fake.loadProcessArgsForCall)
}

func (fake *FakeTask) LoadProcessArgsForCall(i int) (context.Context, string, cio.Attach) {
	fake.loadProcessMutex.RLock()
	defer fake.loadProcessMutex.RUnlock()
	return fake.loadProcessArgsForCall[i].arg1, fake.loadProcessArgsForCall[i].arg2, fake.loadProcessArgsForCall[i].arg3
}

func (fake *FakeTask) LoadProcessReturns(result1 containerd.Process, result2 error) {
	fake.LoadProcessStub = nil
	fake.loadProcessReturns = struct {
		result1 containerd.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) LoadProcessReturnsOnCall(i int, result1 containerd.Process, result2 error) {
	fake.LoadProcessStub = nil
	if fake.loadProcessReturnsOnCall == nil {
		fake.loadProcessReturnsOnCall = make(map[int]struct {
			result1 containerd.Process
			result2 error
		})
	}
	fake.loadProcessReturnsOnCall[i] = struct {
		result1 containerd.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) Metrics(arg1 context.Context) (*types.Metric, error) {
	fake.metricsMutex.Lock()
	ret, specificReturn := fake.metricsReturnsOnCall[len(fake.metricsArgsForCall)]
	fake.metricsArgsForCall = append(fake.metricsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Metrics", []interface{}{arg1})
	fake.metricsMutex.Unlock()
	if fake.MetricsStub != nil {
		return fake.MetricsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.metricsReturns.result1, fake.metricsReturns.result2
}

func (fake *FakeTask) MetricsCallCount() int {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return len(fake.metricsArgsForCall)
}

func (fake *FakeTask) MetricsArgsForCall(i int) context.Context {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return fake.metricsArgsForCall[i].arg1
}

func (fake *FakeTask) MetricsReturns(result1 *types.Metric, result2 error) {
	fake.MetricsStub = nil
	fake.metricsReturns = struct {
		result1 *types.Metric
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) MetricsReturnsOnCall(i int, result1 *types.Metric, result2 error) {
	fake.MetricsStub = nil
	if fake.metricsReturnsOnCall == nil {
		fake.metricsReturnsOnCall = make(map[int]struct {
			result1 *types.Metric
			result2 error
		})
	}
	fake.metricsReturnsOnCall[i] = struct {
		result1 *types.Metric
		result2 error
	}{result1, result2}
}

func (fake *FakeTask) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.pidMutex.RLock()
	defer fake.pidMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.killMutex.RLock()
	defer fake.killMutex.RUnlock()
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	fake.closeIOMutex.RLock()
	defer fake.closeIOMutex.RUnlock()
	fake.resizeMutex.RLock()
	defer fake.resizeMutex.RUnlock()
	fake.iOMutex.RLock()
	defer fake.iOMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	fake.pidsMutex.RLock()
	defer fake.pidsMutex.RUnlock()
	fake.checkpointMutex.RLock()
	defer fake.checkpointMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.loadProcessMutex.RLock()
	defer fake.loadProcessMutex.RUnlock()
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTask) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ runcontainerd.Task = new(FakeTask)
